{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.8", "generated_at": "2025-06-11T12:56:31.578097Z", "invocation_id": "8bf6a0b0-6add-44f9-9a4a-7af714d7c66b", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-11T12:56:31.342267Z", "completed_at": "2025-06-11T12:56:31.347503Z"}, {"name": "execute", "started_at": "2025-06-11T12:56:31.347668Z", "completed_at": "2025-06-11T12:56:31.380858Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.039295196533203125, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.claude_pipeline.bronze_webhooks", "compiled": true, "compiled_code": "\n\n-- Bronze layer: Deduplicated view of raw webhook data from MinIO\nSELECT \n    message_id,\n    timestamp as webhook_timestamp,\n    source_ip,\n    file_path,\n    payload,\n    kafka_timestamp,\n    processed_at,\n    processing_date,\n    processing_hour,\n    ROW_NUMBER() OVER (\n        PARTITION BY message_id \n        ORDER BY processed_at DESC\n    ) as row_num\nFROM read_parquet('s3://webhook-data/processed-webhooks/**/*.parquet')\nWHERE message_id IS NOT NULL", "relation_name": "\"analytics\".\"main\".\"bronze_webhooks\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-11T12:56:31.383129Z", "completed_at": "2025-06-11T12:56:31.386828Z"}, {"name": "execute", "started_at": "2025-06-11T12:56:31.386959Z", "completed_at": "2025-06-11T12:56:31.529423Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.14996552467346191, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.claude_pipeline.silver_webhook_events", "compiled": true, "compiled_code": "\n\n-- Silver layer: Cleaned and categorized webhook events\nSELECT \n    message_id,\n    \n    -- Standardize timestamp format\n    CASE \n        WHEN webhook_timestamp ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}'\n        THEN CAST(webhook_timestamp AS TIMESTAMP)\n        ELSE NULL\n    END as event_timestamp,\n    \n    source_ip,\n    file_path,\n    \n    -- Parse JSON payload safely\n    CASE \n        WHEN JSON_VALID(payload) THEN payload::JSON\n        ELSE NULL\n    END as payload_json,\n    \n    -- Extract specific fields from payload\n    CASE \n        WHEN JSON_VALID(payload) THEN JSON_EXTRACT(payload, '$.source')\n        ELSE NULL\n    END as payload_source,\n    \n    CASE \n        WHEN JSON_VALID(payload) THEN JSON_EXTRACT(payload, '$.test')\n        ELSE NULL\n    END as payload_test,\n    \n    CASE \n        WHEN JSON_VALID(payload) THEN JSON_EXTRACT(payload, '$.value')\n        ELSE NULL\n    END as payload_value,\n    \n    -- Categorize event types\n    CASE \n        WHEN payload LIKE '%transaction%' AND payload LIKE '%SWAP%' THEN 'solana_swap'\n        WHEN payload LIKE '%transaction%' THEN 'solana_transaction'\n        WHEN payload LIKE '%test%' THEN 'test_event'\n        ELSE 'unknown'\n    END as event_type,\n    \n    -- Quality flags\n    CASE WHEN JSON_VALID(payload) THEN true ELSE false END as has_valid_json,\n    CASE WHEN source_ip IS NOT NULL THEN true ELSE false END as has_source_ip,\n    \n    -- Processing metadata\n    kafka_timestamp,\n    processed_at,\n    processing_date,\n    \n    -- Add silver processing timestamp\n    CURRENT_TIMESTAMP as silver_processed_at\n    \nFROM \"analytics\".\"main\".\"bronze_webhooks\"\nWHERE row_num = 1  -- Only include deduplicated records\n\n\n  -- Only process new data since last run\n  AND processed_at > (SELECT MAX(processed_at) FROM \"analytics\".\"main\".\"silver_webhook_events\")\n", "relation_name": "\"analytics\".\"main\".\"silver_webhook_events\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-11T12:56:31.534520Z", "completed_at": "2025-06-11T12:56:31.536280Z"}, {"name": "execute", "started_at": "2025-06-11T12:56:31.536421Z", "completed_at": "2025-06-11T12:56:31.552703Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.018730640411376953, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.claude_pipeline.silver_data_quality_metrics", "compiled": true, "compiled_code": "\n\n-- Silver layer: Data quality metrics by processing date\nSELECT \n    processing_date,\n    COUNT(*) as total_events,\n    COUNT(CASE WHEN has_valid_json THEN 1 END) as valid_json_events,\n    COUNT(CASE WHEN has_source_ip THEN 1 END) as events_with_source_ip,\n    COUNT(CASE WHEN event_timestamp IS NOT NULL THEN 1 END) as events_with_valid_timestamp,\n    COUNT(CASE WHEN event_type = 'unknown' THEN 1 END) as unknown_event_types,\n    COUNT(DISTINCT message_id) as unique_message_ids,\n    \n    -- Quality percentages\n    ROUND(COUNT(CASE WHEN has_valid_json THEN 1 END) * 100.0 / COUNT(*), 2) as json_validity_pct,\n    ROUND(COUNT(CASE WHEN event_timestamp IS NOT NULL THEN 1 END) * 100.0 / COUNT(*), 2) as timestamp_validity_pct,\n    ROUND(COUNT(CASE WHEN event_type != 'unknown' THEN 1 END) * 100.0 / COUNT(*), 2) as categorization_pct,\n    \n    -- Event type distribution\n    COUNT(CASE WHEN event_type = 'solana_swap' THEN 1 END) as solana_swap_count,\n    COUNT(CASE WHEN event_type = 'solana_transaction' THEN 1 END) as solana_transaction_count,\n    COUNT(CASE WHEN event_type = 'test_event' THEN 1 END) as test_event_count,\n    \n    -- Processing metadata\n    MIN(silver_processed_at) as first_processed,\n    MAX(silver_processed_at) as last_processed,\n    CURRENT_TIMESTAMP as metrics_calculated_at\n    \nFROM \"analytics\".\"main\".\"silver_webhook_events\"\n\n\n  -- Only calculate metrics for new processing dates\n  WHERE processing_date > (SELECT MAX(processing_date) FROM \"analytics\".\"main\".\"silver_data_quality_metrics\")\n\n\nGROUP BY processing_date\nORDER BY processing_date", "relation_name": "\"analytics\".\"main\".\"silver_data_quality_metrics\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-11T12:56:31.554129Z", "completed_at": "2025-06-11T12:56:31.555710Z"}, {"name": "execute", "started_at": "2025-06-11T12:56:31.555841Z", "completed_at": "2025-06-11T12:56:31.575080Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.021581172943115234, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.claude_pipeline.silver_transaction_details", "compiled": true, "compiled_code": "\n\n-- Silver layer: Transaction-specific details for Solana events\nSELECT \n    message_id,\n    event_timestamp,\n    event_type,\n    \n    -- Extract transaction-specific fields from JSON payload\n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.transactionType')\n        ELSE NULL\n    END as transaction_type,\n    \n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.transactionAmount')\n        ELSE NULL\n    END as transaction_amount,\n    \n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.tokenA')\n        ELSE NULL\n    END as token_a,\n    \n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.tokenB')\n        ELSE NULL\n    END as token_b,\n    \n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.accountKeys')\n        ELSE NULL\n    END as account_keys,\n    \n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.signature')\n        ELSE NULL\n    END as transaction_signature,\n    \n    CASE \n        WHEN payload_json IS NOT NULL THEN JSON_EXTRACT(payload_json, '$.fee')\n        ELSE NULL\n    END as transaction_fee,\n    \n    -- Processing metadata\n    processing_date,\n    silver_processed_at\n    \nFROM \"analytics\".\"main\".\"silver_webhook_events\"\nWHERE event_type IN ('solana_swap', 'solana_transaction')\n\n\n  -- Only process new transactions since last run\n  AND silver_processed_at > (SELECT MAX(silver_processed_at) FROM \"analytics\".\"main\".\"silver_transaction_details\")\n", "relation_name": "\"analytics\".\"main\".\"silver_transaction_details\"", "batch_results": null}], "elapsed_time": 0.28879261016845703, "args": {"warn_error_options": {"include": [], "exclude": []}, "log_path": "/usr/app/dbt/logs", "cache_selected_only": false, "introspect": true, "which": "run", "skip_nodes_if_on_run_start_fails": false, "version_check": true, "exclude": [], "log_level_file": "debug", "write_json": true, "vars": {}, "send_anonymous_usage_stats": true, "print": true, "favor_state": false, "partial_parse": true, "select": [], "printer_width": 80, "log_format": "default", "partial_parse_file_diff": true, "indirect_selection": "eager", "use_colors": true, "invocation_command": "dbt run", "require_yaml_configuration_for_mf_time_spines": false, "source_freshness_run_project_hooks": false, "log_level": "info", "require_resource_names_without_spaces": false, "show_resource_report": false, "require_nested_cumulative_type_params": false, "require_batched_execution_for_custom_microbatch_strategy": false, "empty": false, "defer": false, "log_file_max_bytes": 10485760, "populate_cache": true, "require_explicit_package_overrides_for_builtin_materializations": true, "state_modified_compare_vars": false, "use_colors_file": true, "state_modified_compare_more_unrendered_values": false, "static_parser": true, "macro_debugging": false, "log_format_file": "debug", "strict_mode": false, "quiet": false, "project_dir": "/usr/app/dbt", "profiles_dir": "/usr/app/dbt"}}